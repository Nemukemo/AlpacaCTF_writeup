## 問題理解
1. 初期化(※但し作成済みの場合処理をスキップする)
   - ユーザーテーブルの作成
   - ユーザーテーブルへvalueの追加(ループ)
   - secretテーブルの作成
   - secretテーブルへFLAGをinsert
2. ログイン処理
   1. HTMLから`username`と`password`を取得
   2. 入力値に"secret"という文字列がある場合、"The table is secret!"を返す(以降waf)
   3. DB接続
   4. 入力値をあらかじめ定義されたクエリの中に挿入してSQLを実行
   5. 結果から1行だけ取得し、`user`に格納
   6. エラーの場合は下記のパターン、そうでない場合は`user`を出力する
      1. SQLエラー：SQL error: {error}
      2. テーブルに値が存在しないとき：invalid credentials
## 解法
> 入力値がエスケープされずそのまま使用し実行する

このことからSQLインジェクションを用いたパターンであることがわかる。FLAGは初期化時にsecretテーブルに値を入れていると記載があるのでSQLインジェクションを用いてsecretテーブル内の`flag`を読み取ればいい。
但し読み取る際には2点注意すべきことがある
- `value`に"secret"という文字列が含まれている場合、if文により処理を強制終了される
- SQL文の結果を1行しか取得しないこと

そのためぺイロードを構築する際に下記の工夫を施す
- 本来のSQL文で何も返さないようにする。或いは処理が失敗するようにする
- wafロジックについて、`in`が大文字小文字を区別するのに対し、SQLiteは大文字小文字を区別しないため、大文字の"SECRET"を記述する
  - ※"secret"でなければなにでもよかったりする
よってペイロードは下記の通りになる
```SQL
' UNION SELECT flag, 1 FROM Secret --
```
これによりSQL文はこのように構築される
```SQL
SELECT * FROM users WHERE username='alpaca' AND password='' UNION SELECT flag, 1 FROM Secret --';
```
- `password=''`となり、パスワードと一致しないためヒットしない
- `UNION SELECT flag, 1 FROM SECRET --';`が実行されるとflagと1が返ってくる。1はusersテーブルと列数を合わせるため